<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Chaos - Made with Ludo.ai</title>
    <meta name="description" content="Interactive playable game created with Ludo.ai - AI-powered game development platform">
    <meta name="generator" content="Ludo.ai">
    <meta name="author" content="Ludo.ai">
    <meta name="keywords" content="playable game, interactive, AI-generated, Ludo.ai, pixijs">
    <meta name="created-date" content="2025-10-04">
    <meta name="game-engine" content="pixijs">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÆ</text></svg>">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .game-header {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
        }
        .game-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 4px 0;
            color: #fff;
        }
        .game-info {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
        }
        .game-description {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0 0 0;
            line-height: 1.4;
        }
        .game-engine {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 8px;
            text-transform: uppercase;
            font-weight: 500;
        }
        #gameContainer {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0;
        }
        canvas {
            display: block;
            margin: 0 auto;
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
        }
        body > canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        .ludo-footer {
            position: fixed;
            bottom: 0;
            right: 0;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            text-decoration: none;
            border-top-left-radius: 4px;
            transition: all 0.2s ease;
            z-index: 1000;
        }
        .ludo-footer:hover {
            background: rgba(0, 0, 0, 0.9);
            color: rgba(255, 255, 255, 0.9);
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1 class="game-title">Color Chaos</h1>
        <p class="game-info">
            Created with Ludo.ai on 2025-10-04
            <span class="game-engine">pixijs</span>
        </p>
        <p class="game-description">A fast-paced game where players must click when the target color appears among moving spots. The game features distinct start and game over screens, with increasing difficulty as more spots appear and move faster.</p>
        <p class="game-description"><strong>How to Play:</strong> Click the 'Start' button to begin. When a target color is displayed on the UI, click anywhere on the screen when a spot of that color appears. Avoid clicking when the target color is not present to save lives. The game ends when you run out of lives or time.</p>
    </div>
    <div id="gameContainer"></div>
    <a href="https://ludo.ai" target="_blank" class="ludo-footer">
        Made with Ludo.ai
    </a>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.3/pixi.min.js" integrity="sha512-o3fAFcbCbTTJRFRNx4vByRZVtdKYF9uklctNjDXrN1JjT00rJxCCyNJSDi35rPBEqzWvYplcHLlEmyW34Ado8A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><script src="https://cdn.jsdelivr.net/npm/pixi-filters@5.3.0/dist/browser/pixi-filters.min.js"></script>
    <script type="module">
        // Ludo.ai Playable Game
        // Generated on: 2025-10-04
        // Engine: pixijs
        // Title: Color Chaos
        
        // Monitor for canvas elements and move them to gameContainer
        const gameContainer = document.getElementById('gameContainer');
        
        // Function to move canvas elements to gameContainer
        function moveCanvasToContainer() {
            const canvases = document.querySelectorAll('body > canvas');
            canvases.forEach(canvas => {
                if (canvas.parentElement === document.body) {
                    gameContainer.appendChild(canvas);
                }
            });
        }
        
        // Monitor for new canvas elements
        const observer = new MutationObserver(() => {
            moveCanvasToContainer();
        });
        observer.observe(document.body, { childList: true });
        
        // Initial check
        setTimeout(moveCanvasToContainer, 100);
        
        const STATE_START_SCREEN = 0;
const STATE_PLAYING = 1;
const STATE_GAME_OVER = 2;
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
const COLORS = [
  { name: '–ö—Ä–∞—Å–Ω—ã–π', value: 0xFF0000 },
  { name: '–ó–µ–ª—ë–Ω—ã–π', value: 0x00FF00 },
  { name: '–°–∏–Ω–∏–π', value: 0x0000FF },
  { name: '–ñ—ë–ª—Ç—ã–π', value: 0xFFFF00 }
];
class Spot {
  constructor(radius, colorValue, isTarget) {
    this.radius = radius;
    this.colorValue = colorValue;
    this.isTarget = isTarget;
    this.graphics = new PIXI.Graphics();
    this.reset();
  }
  reset() {
    this.graphics.clear();
    this.graphics.beginFill(this.colorValue);
    this.graphics.drawCircle(0, 0, this.radius);
    this.graphics.endFill();
    this.graphics.x = Math.random() * (GAME_WIDTH - 2 * this.radius) + this.radius;
    this.graphics.y = Math.random() * (GAME_HEIGHT - 2 * this.radius) + this.radius + 60;
    const angle = Math.random() * Math.PI * 2;
    const speed = 1.5 + Math.random();
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;
    this.active = true;
  }
  setTarget(isTarget) {
    this.isTarget = isTarget;
    this.graphics.clear();
    this.graphics.beginFill(this.colorValue);
    this.graphics.drawCircle(0, 0, this.radius);
    this.graphics.endFill();
  }
  update(speedMultiplier) {
    this.graphics.x += this.vx * speedMultiplier;
    this.graphics.y += this.vy * speedMultiplier;
    if (this.graphics.x - this.radius < 0) {
      this.graphics.x = this.radius;
      this.vx = -this.vx;
    }
    if (this.graphics.x + this.radius > GAME_WIDTH) {
      this.graphics.x = GAME_WIDTH - this.radius;
      this.vx = -this.vx;
    }
    if (this.graphics.y - this.radius < 60) {
      this.graphics.y = 60 + this.radius;
      this.vy = -this.vy;
    }
    if (this.graphics.y + this.radius > GAME_HEIGHT) {
      this.graphics.y = GAME_HEIGHT - this.radius;
      this.vy = -this.vy;
    }
  }
}
class Game {
  constructor() {
    this.app = new PIXI.Application({
      width: GAME_WIDTH,
      height: GAME_HEIGHT,
      backgroundColor: 0x333333,
      antialias: true,
      resolution: 1
    });
    document.body.appendChild(this.app.view);
    this.state = STATE_START_SCREEN;
    this.score = 0;
    this.lives = 3;
    this.timeLeft = 60;
    this.difficultyTimer = 0;
    this.spotSpeedMultiplier = 1;
    this.minSpots = 6;
    this.maxSpots = 20;
    this.spots = [];
    this.targetColor = null;
    this.targetColorIndex = 0;
    this.uiContainer = new PIXI.Container();
    this.spotsContainer = new PIXI.Container();
    this.overlayContainer = new PIXI.Container();
    this.startScreenContainer = new PIXI.Container();
    this.gameOverContainer = new PIXI.Container();
    this.app.stage.addChild(this.uiContainer);
    this.app.stage.addChild(this.spotsContainer);
    this.app.stage.addChild(this.overlayContainer);
    this.app.stage.addChild(this.startScreenContainer);
    this.app.stage.addChild(this.gameOverContainer);
    this.createUI();
    this.createStartScreen();
    this.createGameOverScreen();
    this.setState(STATE_START_SCREEN);
    this.app.ticker.add((delta) => this.update(delta));
    this.app.view.addEventListener('pointerdown', (e) => this.handleClap(e));
  }
  setState(state) {
    this.state = state;
    this.uiContainer.visible = false;
    this.spotsContainer.visible = false;
    this.overlayContainer.visible = false;
    this.startScreenContainer.visible = false;
    this.gameOverContainer.visible = false;
    if (state === STATE_START_SCREEN) {
      this.startScreenContainer.visible = true;
    }
    if (state === STATE_PLAYING) {
      this.uiContainer.visible = true;
      this.spotsContainer.visible = true;
      this.overlayContainer.visible = true;
    }
    if (state === STATE_GAME_OVER) {
      this.gameOverContainer.visible = true;
    }
  }
  createUI() {
    this.targetColorLabel = new PIXI.Text('–ù–∞–π–¥–∏ —Ü–≤–µ—Ç:', {
      fontFamily: 'Arial',
      fontSize: 28,
      fill: 0xffffff,
      align: 'center'
    });
    this.targetColorLabel.anchor.set(0.5, 0.5);
    this.targetColorLabel.x = GAME_WIDTH / 2 - 60;
    this.targetColorLabel.y = 34;
    this.uiContainer.addChild(this.targetColorLabel);
    this.targetColorSwatch = new PIXI.Graphics();
    this.targetColorSwatch.x = GAME_WIDTH / 2 + 70;
    this.targetColorSwatch.y = 34;
    this.uiContainer.addChild(this.targetColorSwatch);
    this.scoreText = new PIXI.Text('–°—á—ë—Ç: 0', {
      fontFamily: 'Arial',
      fontSize: 24,
      fill: 0xffffff
    });
    this.scoreText.x = 20;
    this.scoreText.y = 15;
    this.uiContainer.addChild(this.scoreText);
    this.livesText = new PIXI.Text('–ñ–∏–∑–Ω–∏: 3', {
      fontFamily: 'Arial',
      fontSize: 24,
      fill: 0xffffff
    });
    this.livesText.x = 20;
    this.livesText.y = 45;
    this.uiContainer.addChild(this.livesText);
    this.timerText = new PIXI.Text('–í—Ä–µ–º—è: 60', {
      fontFamily: 'Arial',
      fontSize: 24,
      fill: 0xffffff
    });
    this.timerText.x = GAME_WIDTH - 160;
    this.timerText.y = 15;
    this.uiContainer.addChild(this.timerText);
  }
  createStartScreen() {
    this.startScreenContainer.removeChildren();
    const title = new PIXI.Text('–¶–≤–µ—Ç–Ω–æ–π —Ö–∞–æ—Å', {
      fontFamily: 'Arial',
      fontSize: 56,
      fill: 0xffffff,
      fontWeight: 'bold',
      align: 'center'
    });
    title.anchor.set(0.5, 0.5);
    title.x = GAME_WIDTH / 2;
    title.y = 160;
    this.startScreenContainer.addChild(title);
    const instr = new PIXI.Text(
      '–ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å", —á—Ç–æ–±—ã –∏–≥—Ä–∞—Ç—å.\n–ö–ª–∏–∫–Ω–∏—Ç–µ, –∫–æ–≥–¥–∞ –Ω–∞ —ç–∫—Ä–∞–Ω–µ –µ—Å—Ç—å –Ω—É–∂–Ω—ã–π —Ü–≤–µ—Ç!',
      {
        fontFamily: 'Arial',
        fontSize: 26,
        fill: 0xffffff,
        align: 'center',
        wordWrap: true,
        wordWrapWidth: 600
      }
    );
    instr.anchor.set(0.5, 0.5);
    instr.x = GAME_WIDTH / 2;
    instr.y = 250;
    this.startScreenContainer.addChild(instr);
    const button = new PIXI.Graphics();
    button.beginFill(0x4444ff);
    button.drawRoundedRect(0, 0, 240, 70, 20);
    button.endFill();
    button.x = GAME_WIDTH / 2 - 120;
    button.y = 360;
    button.eventMode = 'static';
    button.buttonMode = true;
    this.startScreenContainer.addChild(button);
    const btnText = new PIXI.Text('–ù–∞—á–∞—Ç—å', {
      fontFamily: 'Arial',
      fontSize: 32,
      fill: 0xffffff
    });
    btnText.anchor.set(0.5, 0.5);
    btnText.x = button.x + 120;
    btnText.y = button.y + 35;
    this.startScreenContainer.addChild(btnText);
    button.on('pointertap', () => this.startGame());
    btnText.eventMode = 'static';
    btnText.buttonMode = true;
    btnText.on('pointertap', () => this.startGame());
  }
  createGameOverScreen() {
    this.gameOverContainer.removeChildren();
    const over = new PIXI.Text('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!', {
      fontFamily: 'Arial',
      fontSize: 48,
      fill: 0xffffff,
      fontWeight: 'bold',
      align: 'center'
    });
    over.anchor.set(0.5, 0.5);
    over.x = GAME_WIDTH / 2;
    over.y = 180;
    this.gameOverContainer.addChild(over);
    this.finalScoreText = new PIXI.Text('', {
      fontFamily: 'Arial',
      fontSize: 34,
      fill: 0xffee44,
      align: 'center'
    });
    this.finalScoreText.anchor.set(0.5, 0.5);
    this.finalScoreText.x = GAME_WIDTH / 2;
    this.finalScoreText.y = 260;
    this.gameOverContainer.addChild(this.finalScoreText);
    const button = new PIXI.Graphics();
    button.beginFill(0x33cc66);
    button.drawRoundedRect(0, 0, 250, 70, 20);
    button.endFill();
    button.x = GAME_WIDTH / 2 - 125;
    button.y = 340;
    button.eventMode = 'static';
    button.buttonMode = true;
    this.gameOverContainer.addChild(button);
    const btnText = new PIXI.Text('–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞', {
      fontFamily: 'Arial',
      fontSize: 32,
      fill: 0xffffff
    });
    btnText.anchor.set(0.5, 0.5);
    btnText.x = button.x + 125;
    btnText.y = button.y + 35;
    this.gameOverContainer.addChild(btnText);
    button.on('pointertap', () => this.startGame());
    btnText.eventMode = 'static';
    btnText.buttonMode = true;
    btnText.on('pointertap', () => this.startGame());
  }
  startGame() {
    this.score = 0;
    this.lives = 3;
    this.timeLeft = 60;
    this.difficultyTimer = 0;
    this.spotSpeedMultiplier = 1;
    this.minSpots = 6;
    this.spots = [];
    this.spotsContainer.removeChildren();
    this.nextTargetColor();
    for (let i = 0; i < this.minSpots; i++) {
      this.spawnSpot();
    }
    this.updateUI();
    this.setState(STATE_PLAYING);
  }
  update(delta) {
    if (this.state === STATE_PLAYING) {
      this.difficultyTimer += delta / 60;
      if (this.difficultyTimer > 7 && this.minSpots < this.maxSpots) {
        this.minSpots++;
        this.difficultyTimer = 0;
        this.spotSpeedMultiplier += 0.12;
        this.spawnSpot();
      }
      for (let spot of this.spots) {
        spot.update(this.spotSpeedMultiplier);
      }
      this.ensureSpots();
      this.timeLeft -= delta / 60;
      if (this.timeLeft <= 0) {
        this.timeLeft = 0;
        this.gameOver();
      }
      this.updateUI();
    }
  }
  updateUI() {
    this.scoreText.text = '–°—á—ë—Ç: ' + this.score;
    this.livesText.text = '–ñ–∏–∑–Ω–∏: ' + this.lives;
    this.timerText.text = '–í—Ä–µ–º—è: ' + Math.ceil(this.timeLeft);
    this.targetColorLabel.text = '–ù–∞–π–¥–∏ —Ü–≤–µ—Ç:';
    this.targetColorSwatch.clear();
    this.targetColorSwatch.beginFill(this.targetColor.value);
    this.targetColorSwatch.drawCircle(0, 0, 28);
    this.targetColorSwatch.endFill();
  }
  ensureSpots() {
    let count = 0;
    for (let spot of this.spots) {
      if (spot.active) count++;
    }
    while (count < this.minSpots) {
      this.spawnSpot();
      count++;
    }
    let targetPresent = false;
    for (let spot of this.spots) {
      if (spot.active && spot.isTarget && spot.colorValue === this.targetColor.value) {
        targetPresent = true;
        break;
      }
    }
    if (!targetPresent) {
      this.spawnSpot(true);
    }
  }
  spawnSpot(forceTarget) {
    let isTarget = forceTarget || false;
    let colorObj;
    if (isTarget) {
      colorObj = this.targetColor;
    } else {
      let colorChoices = COLORS.filter(c => c.value !== this.targetColor.value);
      colorObj = colorChoices[Math.floor(Math.random() * colorChoices.length)];
      if (Math.random() < 0.18) colorObj = this.targetColor;
      isTarget = colorObj.value === this.targetColor.value;
    }
    const spot = new Spot(24, colorObj.value, isTarget);
    this.spots.push(spot);
    this.spotsContainer.addChild(spot.graphics);
  }
  handleClap(e) {
    if (this.state !== STATE_PLAYING) return;
    let anyTarget = false;
    for (let spot of this.spots) {
      if (spot.active && spot.isTarget && spot.colorValue === this.targetColor.value) {
        anyTarget = true;
        break;
      }
    }
    if (anyTarget) {
      this.score += 1;
      this.flashScreen(0xffffff, 0.22);
      this.nextTargetColor();
    } else {
      this.lives -= 1;
      this.flashScreen(0xff0000, 0.18);
      if (this.lives <= 0) {
        this.lives = 0;
        this.gameOver();
      }
    }
    this.updateUI();
  }
  nextTargetColor() {
    let prev = this.targetColor;
    let idx;
    do {
      idx = Math.floor(Math.random() * COLORS.length);
    } while (prev && COLORS[idx].value === prev.value);
    this.targetColor = COLORS[idx];
    for (let spot of this.spots) {
      spot.setTarget(spot.colorValue === this.targetColor.value);
    }
  }
  flashScreen(color, duration) {
    this.overlayContainer.removeChildren();
    const overlay = new PIXI.Graphics();
    overlay.beginFill(color, 0.45);
    overlay.drawRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    overlay.endFill();
    this.overlayContainer.addChild(overlay);
    overlay.alpha = 1;
    let elapsed = 0;
    const fade = (delta) => {
      elapsed += this.app.ticker.deltaMS / 1000;
      overlay.alpha = 1 - elapsed / duration;
      if (elapsed >= duration) {
        this.overlayContainer.removeChildren();
        this.app.ticker.remove(fade);
      }
    };
    this.app.ticker.add(fade);
  }
  gameOver() {
    this.setState(STATE_GAME_OVER);
    this.finalScoreText.text = '–°—á—ë—Ç: ' + this.score;
  }
}
new Game();
    </script>
</body>
</html>